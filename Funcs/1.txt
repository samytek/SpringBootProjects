@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String username;
    private String currentSite;
    private String temporarySite;
    private LocalDateTime startDate;
    private LocalDateTime endDate;

    // Getters and Setters
}

public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
}

//@Configuration
//@EnableScheduling
public class SiteResetScheduler {

    @Autowired
    private UserService userService;

    @Scheduled(cron = "0 0 0 * * *") // Every 01 minute public void execute()
    public void execute() {
        logger.info(">>>>>>>>>>>>>>>>>>>>>>>>>>>> Data Job Start >>>>>>>>>>>>>>>>>>>>>>> " + new Date());
        try {
        userService.resetSiteIfExpired();
        } catch (Exception e) {
            logger.error(ErrorHandler.getErrorMessageLog(new Object() {}.getClass(), e));
        }
		logger.info(">>>>>>>>>>>>>>>>>>>>>>>>>>>> Data Job End >>>>>>>>>>>>>>>>>>>>>>> " + new Date());
    }

    @Scheduled(cron = "0 0 0 * * *") // Runs daily at midnight
    public void resetExpiredSites() {
    }
}

@SuppressWarnings({ "rawtypes", "unchecked" })
@RequestMapping(value = "/getUserMapping", method = RequestMethod.POST)
public ResponseEntity getUserMapping(@RequestBody String requestData) {
	JSONObject requestJSONObj = new JSONObject(requestData);
	JSONObject responseJSON = userRolesService.getUserMapping(requestJSONObj);
	return new ResponseEntity(responseJSON.toString(), HttpStatus.OK);
}
	
@Operation(summary = "Update Temporary Site Mapping")
@ApiResponses(value = {
    @ApiResponse(responseCode = "200", description = "Site mapping updated successfully", content = {
        @Content(mediaType = MediaType.APPLICATION_JSON_VALUE, schema = @Schema(implementation = User.class))
    }),
    @ApiResponse(responseCode = "404", description = "User not found", content = @Content)
})
@GetMapping(value = "/{username}/temporary-site", produces = MediaType.APPLICATION_JSON_VALUE)
@ActionMapping(actionId = AWConstants.ActionIdConstants.UPDATE_TEMPORARY_SITE, appId = AWConstants.AW_PORTAL_APP, subAppId = "")
public ResponseEntity<User> updateTemporarySite(
        @RequestParam(value = "newSite") String newSite,
        @RequestParam(value = "startDate") String startDate,
        @RequestParam(value = "endDate") String endDate,
        @RequestParam(value = "userTimezone", required = false) String userTimezone,
        @RequestParam(value = "projectId") Long prjSeqId,
        @RequestAttribute(name = JwtConstants.USER_DETAIL_CLAIM, required = false) ClaimUserInfo claimUserInfo
) throws AppServiceException {
    // Logic to update the site
    User updatedUser = userService.updateTemporarySite(prjSeqId, newSite, startDate, endDate, userTimezone);
    return ResponseEntity.ok(updatedUser);
}

@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    public User updateTemporarySite(String username, String newSite, LocalDateTime startDate, LocalDateTime endDate) {
        if (endDate.isBefore(startDate)) {
            throw new IllegalArgumentException("End date must be after start date.");
        }

        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new RuntimeException("User not found"));

        user.setTemporarySite(newSite);
        user.setStartDate(startDate);
        user.setEndDate(endDate);
        userRepository.save(user);
        return user;
    }

    public void resetSiteIfExpired() {
		// write logic to fetch actual site based on user mapping and set inside setCurrentSite
        List<User> users = userRepository.findAll();
        for (User user : users) {
            if (user.getEndDate() != null &&
                    user.getEndDate().isBefore(LocalDateTime.now())) {
                user.setCurrentSite(user.getTemporarySite());
                user.setTemporarySite(null);
                user.setStartDate(null);
                user.setEndDate(null);
                userRepository.save(user);
            }
        }
    }
}


#####################################################################################################################

2. Test Cases for Controller

@SpringBootTest
@AutoConfigureMockMvc
class UserControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private UserService userService;

    @Test
    void updateTemporarySite_ShouldReturnUpdatedUser() throws Exception {
        // Given
        String username = "johndoe";
        String newSite = "Harrogate";
        String startDate = "26-11-2024";
        String endDate = "28-11-2024";

        User mockUser = new User();
        mockUser.setId(1L);
        mockUser.setUsername(username);
        mockUser.setCurrentSite("Denver");
        mockUser.setTemporarySite(newSite);
        mockUser.setStartDate(LocalDateTime.of(2024, 11, 26, 0, 0));
        mockUser.setEndDate(LocalDateTime.of(2024, 11, 28, 23, 59, 59));

        Mockito.when(userService.updateTemporarySite(Mockito.eq(username), Mockito.eq(newSite),
                Mockito.any(LocalDateTime.class), Mockito.any(LocalDateTime.class)))
                .thenReturn(mockUser);

        // When & Then
        mockMvc.perform(put("/users/{username}/temporary-site", username)
                        .param("newSite", newSite)
                        .param("startDate", startDate)
                        .param("endDate", endDate))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.username").value(username))
                .andExpect(jsonPath("$.temporarySite").value(newSite))
                .andExpect(jsonPath("$.currentSite").value("Denver"));

        Mockito.verify(userService, Mockito.times(1)).updateTemporarySite(Mockito.eq(username),
                Mockito.eq(newSite), Mockito.any(LocalDateTime.class), Mockito.any(LocalDateTime.class));
    }
}


3. Test Cases for Service
@ExtendWith(MockitoExtension.class)
class UserServiceTest {

    @Mock
    private UserRepository userRepository;

    @InjectMocks
    private UserService userService;

    @Test
    void updateTemporarySite_ShouldUpdateUserWithTemporarySite() {
        // Given
        String username = "johndoe";
        String newSite = "Harrogate";
        LocalDateTime startDate = LocalDateTime.of(2024, 11, 26, 0, 0);
        LocalDateTime endDate = LocalDateTime.of(2024, 11, 28, 23, 59, 59);

        User user = new User();
        user.setId(1L);
        user.setUsername(username);
        user.setCurrentSite("Denver");

        Mockito.when(userRepository.findByUsername(username)).thenReturn(Optional.of(user));
        Mockito.when(userRepository.save(Mockito.any(User.class))).thenAnswer(i -> i.getArguments()[0]);

        // When
        User updatedUser = userService.updateTemporarySite(username, newSite, startDate, endDate);

        // Then
        Assertions.assertEquals(newSite, updatedUser.getTemporarySite());
        Assertions.assertEquals(startDate, updatedUser.getStartDate());
        Assertions.assertEquals(endDate, updatedUser.getEndDate());
        Mockito.verify(userRepository, Mockito.times(1)).save(user);
    }

    @Test
    void resetSiteIfExpired_ShouldResetExpiredTemporarySites() {
        // Given
        User user = new User();
        user.setId(1L);
        user.setUsername("johndoe");
        user.setCurrentSite("Denver");
        user.setTemporarySite("Harrogate");
        user.setStartDate(LocalDateTime.of(2024, 11, 26, 0, 0));
        user.setEndDate(LocalDateTime.of(2024, 11, 28, 23, 59, 59));

        List<User> users = List.of(user);

        Mockito.when(userRepository.findAll()).thenReturn(users);
        Mockito.when(userRepository.save(Mockito.any(User.class))).thenAnswer(i -> i.getArguments()[0]);

        // When
        userService.resetSiteIfExpired();

        // Then
        Assertions.assertEquals("Harrogate", user.getCurrentSite());
        Assertions.assertNull(user.getTemporarySite());
        Assertions.assertNull(user.getStartDate());
        Assertions.assertNull(user.getEndDate());
        Mockito.verify(userRepository, Mockito.times(1)).save(user);
    }
}

package com.example.SpringBootBatchProcessingJPA.Exception;

import jakarta.xml.bind.JAXBException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseStatus;

import java.sql.SQLException;
import java.util.HashMap;
import java.util.Map;

@ControllerAdvice
public class GlobalExceptionHandler {

    @ResponseStatus(HttpStatus.BAD_REQUEST)
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Object> handleValidationExceptions(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getAllErrors().forEach((error) -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });
        return new ResponseEntity<>(errors, HttpStatus.BAD_REQUEST);
    }

    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    @ExceptionHandler(SQLException.class)
    public ResponseEntity<String> handleSQLException(SQLException ex) {
        return new ResponseEntity<>("Database error: " + ex.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
    }

    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    @ExceptionHandler(NullPointerException.class)
    public ResponseEntity<String> handleNullPointerException(NullPointerException ex) {
        return new ResponseEntity<>("A null value was encountered: " + ex.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
    }

    @ResponseStatus(HttpStatus.BAD_REQUEST)
    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<String> handleIllegalArgumentException(IllegalArgumentException ex) {
        return new ResponseEntity<>("Invalid argument: " + ex.getMessage(), HttpStatus.BAD_REQUEST);
    }

    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    @ExceptionHandler(JAXBException.class)
    public ResponseEntity<String> handleJAXBException(JAXBException ex) {
        return new ResponseEntity<>("XML processing error: " + ex.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
    }

    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    @ExceptionHandler(RuntimeException.class)
    public ResponseEntity<String> handleRuntimeException(RuntimeException ex) {
        return new ResponseEntity<>("An unexpected error occurred: " + ex.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
    }

    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleGenericException(Exception ex) {
        return new ResponseEntity<>("An error occurred: " + ex.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
    }
}