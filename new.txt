@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    public User updateUserSite(Long userId, String currentSite, String temporarySite, LocalDateTime startDate, LocalDateTime endDate) {
        // Validate endDate if it is provided
        if (startDate != null && endDate != null && endDate.isBefore(startDate)) {
            throw new IllegalArgumentException("End date must be after start date.");
        }

        // Fetch the user from the repository
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("User not found"));

        // Update user fields based on the logic
        if (temporarySite == null || temporarySite.isBlank()) {
            user.setCurrentSite(currentSite);
            user.setIscurrentSiteActive(true);  // Make current site active
            user.setTemporarySite(null);
            user.setIstemporarySiteActive(false);  // Make temporary site inactive
            user.setStartDate(null);
            user.setEndDate(null);
        } else {
            user.setCurrentSite(currentSite);
            user.setIscurrentSiteActive(false);  // Make current site inactive
            user.setTemporarySite(temporarySite);
            user.setIstemporarySiteActive(true);  // Make temporary site active
            user.setStartDate(startDate);
            user.setEndDate(endDate);
        }

        // Save updated user to the repository
        return userRepository.save(user);
    }
}

public void resetSiteIfExpired() {
    List<User> users = userRepository.findAll();
    for (User user : users) {
        if (user.getEndDate() != null && user.getEndDate().isBefore(LocalDateTime.now())) {
            // Make the temporary site inactive and current site active
            user.setIstemporarySiteActive(false); // Temporary site is inactive
            user.setIscurrentSiteActive(true);    // Current site is active

            // Leave the rest of the details as is (temporarySite, startDate, endDate)
            userRepository.save(user);
        }
    }
}

####################################################################################################################

@ExtendWith(MockitoExtension.class)
class UserServiceTest {

    @Mock
    private UserRepository userRepository;

    @InjectMocks
    private UserService userService;

    @Test
    void updateUserSite_ShouldSetCurrentSiteActive_WhenTemporarySiteIsBlank() {
        // Given
        Long userId = 1L;
        String currentSite = "Denver";
        String temporarySite = null;
        LocalDateTime startDate = null;
        LocalDateTime endDate = null;

        User mockUser = new User();
        mockUser.setId(userId);
        mockUser.setCurrentSite("OldSite");
        mockUser.setIstemporarySiteActive(true);

        Mockito.when(userRepository.findById(userId)).thenReturn(Optional.of(mockUser));
        Mockito.when(userRepository.save(Mockito.any(User.class))).thenAnswer(i -> i.getArguments()[0]);

        // When
        User updatedUser = userService.updateUserSite(userId, currentSite, temporarySite, startDate, endDate);

        // Then
        Assertions.assertEquals(currentSite, updatedUser.getCurrentSite());
        Assertions.assertTrue(updatedUser.isIscurrentSiteActive());
        Assertions.assertNull(updatedUser.getTemporarySite());
        Assertions.assertFalse(updatedUser.isIstemporarySiteActive());
        Assertions.assertNull(updatedUser.getStartDate());
        Assertions.assertNull(updatedUser.getEndDate());

        Mockito.verify(userRepository, Mockito.times(1)).findById(userId);
        Mockito.verify(userRepository, Mockito.times(1)).save(updatedUser);
    }

    @Test
    void updateUserSite_ShouldSetTemporarySiteActive_WhenTemporarySiteIsProvided() {
        // Given
        Long userId = 1L;
        String currentSite = "Denver";
        String temporarySite = "Harrogate";
        LocalDateTime startDate = LocalDateTime.of(2024, 11, 26, 0, 0);
        LocalDateTime endDate = LocalDateTime.of(2024, 11, 28, 23, 59, 59);

        User mockUser = new User();
        mockUser.setId(userId);
        mockUser.setCurrentSite("OldSite");
        mockUser.setIscurrentSiteActive(true);

        Mockito.when(userRepository.findById(userId)).thenReturn(Optional.of(mockUser));
        Mockito.when(userRepository.save(Mockito.any(User.class))).thenAnswer(i -> i.getArguments()[0]);

        // When
        User updatedUser = userService.updateUserSite(userId, currentSite, temporarySite, startDate, endDate);

        // Then
        Assertions.assertEquals(currentSite, updatedUser.getCurrentSite());
        Assertions.assertFalse(updatedUser.isIscurrentSiteActive());
        Assertions.assertEquals(temporarySite, updatedUser.getTemporarySite());
        Assertions.assertTrue(updatedUser.isIstemporarySiteActive());
        Assertions.assertEquals(startDate, updatedUser.getStartDate());
        Assertions.assertEquals(endDate, updatedUser.getEndDate());

        Mockito.verify(userRepository, Mockito.times(1)).findById(userId);
        Mockito.verify(userRepository, Mockito.times(1)).save(updatedUser);
    }

    @Test
    void updateUserSite_ShouldThrowException_WhenEndDateIsBeforeStartDate() {
        // Given
        Long userId = 1L;
        String currentSite = "Denver";
        String temporarySite = "Harrogate";
        LocalDateTime startDate = LocalDateTime.of(2024, 11, 28, 0, 0);
        LocalDateTime endDate = LocalDateTime.of(2024, 11, 26, 23, 59);

        User mockUser = new User();
        mockUser.setId(userId);

        Mockito.when(userRepository.findById(userId)).thenReturn(Optional.of(mockUser));

        // When & Then
        IllegalArgumentException exception = Assertions.assertThrows(IllegalArgumentException.class, () ->
                userService.updateUserSite(userId, currentSite, temporarySite, startDate, endDate));

        Assertions.assertEquals("End date must be after start date.", exception.getMessage());
        Mockito.verify(userRepository, Mockito.times(1)).findById(userId);
        Mockito.verify(userRepository, Mockito.never()).save(Mockito.any(User.class));
    }

    @Test
    void updateUserSite_ShouldThrowException_WhenUserNotFound() {
        // Given
        Long userId = 1L;
        String currentSite = "Denver";
        String temporarySite = "Harrogate";
        LocalDateTime startDate = LocalDateTime.of(2024, 11, 26, 0, 0);
        LocalDateTime endDate = LocalDateTime.of(2024, 11, 28, 23, 59);

        Mockito.when(userRepository.findById(userId)).thenReturn(Optional.empty());

        // When & Then
        RuntimeException exception = Assertions.assertThrows(RuntimeException.class, () ->
                userService.updateUserSite(userId, currentSite, temporarySite, startDate, endDate));

        Assertions.assertEquals("User not found", exception.getMessage());
        Mockito.verify(userRepository, Mockito.times(1)).findById(userId);
        Mockito.verify(userRepository, Mockito.never()).save(Mockito.any(User.class));
    }
}

@ExtendWith(MockitoExtension.class)
class UserServiceTest {

    @Mock
    private UserRepository userRepository;

    @InjectMocks
    private UserService userService;

    @Test
    void resetSiteIfExpired_ShouldUpdateSiteStatus_WhenEndDateIsExpired() {
        // Given
        User user1 = new User();
        user1.setId(1L);
        user1.setCurrentSite("MainSite");
        user1.setIscurrentSiteActive(false); // Initially inactive
        user1.setTemporarySite("TempSite");
        user1.setIstemporarySiteActive(true); // Initially active
        user1.setStartDate(LocalDateTime.of(2024, 11, 20, 0, 0));
        user1.setEndDate(LocalDateTime.of(2024, 11, 25, 23, 59)); // Expired

        User user2 = new User();
        user2.setId(2L);
        user2.setCurrentSite("AnotherMainSite");
        user2.setIscurrentSiteActive(false);
        user2.setTemporarySite("AnotherTempSite");
        user2.setIstemporarySiteActive(true);
        user2.setStartDate(LocalDateTime.of(2024, 11, 22, 0, 0));
        user2.setEndDate(LocalDateTime.of(2024, 12, 1, 23, 59)); // Not expired

        List<User> users = Arrays.asList(user1, user2);

        Mockito.when(userRepository.findAll()).thenReturn(users);
        Mockito.when(userRepository.save(Mockito.any(User.class))).thenAnswer(i -> i.getArguments()[0]);

        // When
        userService.resetSiteIfExpired();

        // Then
        // Verify the first user is updated correctly (endDate is expired)
        Assertions.assertFalse(user1.isIstemporarySiteActive()); // Temporary site should be inactive
        Assertions.assertTrue(user1.isIscurrentSiteActive());    // Current site should be active
        Assertions.assertEquals("TempSite", user1.getTemporarySite()); // Other fields remain unchanged
        Assertions.assertEquals(LocalDateTime.of(2024, 11, 20, 0, 0), user1.getStartDate());
        Assertions.assertEquals(LocalDateTime.of(2024, 11, 25, 23, 59), user1.getEndDate());

        // Verify the second user is not updated (endDate is not expired)
        Assertions.assertTrue(user2.isIstemporarySiteActive()); // Temporary site remains active
        Assertions.assertFalse(user2.isIscurrentSiteActive());  // Current site remains inactive
        Assertions.assertEquals("AnotherTempSite", user2.getTemporarySite());
        Assertions.assertEquals(LocalDateTime.of(2024, 11, 22, 0, 0), user2.getStartDate());
        Assertions.assertEquals(LocalDateTime.of(2024, 12, 1, 23, 59), user2.getEndDate());

        Mockito.verify(userRepository, Mockito.times(1)).findAll();
        Mockito.verify(userRepository, Mockito.times(1)).save(user1);
        Mockito.verify(userRepository, Mockito.never()).save(user2);
    }
}
ngOnInit() {
    // Set the `minDate` property to today's date in `YYYY-MM-DD` format
    const today = new Date();
    const year = today.getFullYear();
    const month = String(today.getMonth() + 1).padStart(2, '0'); // Add leading zero if needed
    const day = String(today.getDate()).padStart(2, '0'); // Add leading zero if needed
    this.minDate = `${year}-${month}-${day}`;
  }
}
